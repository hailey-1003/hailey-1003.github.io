<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>（一）ES6：新的声明方式 let与const | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、新的声明方式：let 不属于顶层对象 window 不允许重复声明 不存在变量提升 暂时性死区 块级作用域  1.1 不属于顶层对象 windowvar 声明方式：写 var 和不写 var 有区别写 var 是在当前作用域下声明一个变量；不写 var 是给全局对象 window 添加了一个属性，并且对属性进行了赋值。（可以使用 delete 进行验证，delete 只能删除属性不能删除变量）">
<meta property="og:type" content="article">
<meta property="og:title" content="（一）ES6：新的声明方式 let与const">
<meta property="og:url" content="http://example.com/2021/02/15/ES001/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、新的声明方式：let 不属于顶层对象 window 不允许重复声明 不存在变量提升 暂时性死区 块级作用域  1.1 不属于顶层对象 windowvar 声明方式：写 var 和不写 var 有区别写 var 是在当前作用域下声明一个变量；不写 var 是给全局对象 window 添加了一个属性，并且对属性进行了赋值。（可以使用 delete 进行验证，delete 只能删除属性不能删除变量）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/02/15/ES001/1.jpeg">
<meta property="article:published_time" content="2021-02-15T13:25:36.000Z">
<meta property="article:modified_time" content="2021-05-24T07:48:32.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="ES">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/02/15/ES001/1.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-ES001" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/15/ES001/" class="article-date">
  <time class="dt-published" datetime="2021-02-15T13:25:36.000Z" itemprop="datePublished">2021-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      （一）ES6：新的声明方式 let与const
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、新的声明方式：let"><a href="#一、新的声明方式：let" class="headerlink" title="一、新的声明方式：let"></a>一、新的声明方式：let</h2><ul>
<li>不属于顶层对象 window</li>
<li>不允许重复声明</li>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
</ul>
<h3 id="1-1-不属于顶层对象-window"><a href="#1-1-不属于顶层对象-window" class="headerlink" title="1.1 不属于顶层对象 window"></a>1.1 不属于顶层对象 window</h3><h4 id="var-声明方式：写-var-和不写-var-有区别"><a href="#var-声明方式：写-var-和不写-var-有区别" class="headerlink" title="var 声明方式：写 var 和不写 var 有区别"></a>var 声明方式：写 var 和不写 var 有区别</h4><p><strong>写 var 是在当前作用域下声明一个变量；不写 var 是给全局对象 window 添加了一个属性，并且对属性进行了赋值。</strong>（可以使用 delete 进行验证，delete 只能删除属性不能删除变量）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局环境下</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>) <span class="comment">// 输出5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>) <span class="comment">// 输出6</span></span><br></pre></td></tr></table></figure>

<p>既然 a 是一个变量，为什么通过 window.a 也可以访问到变量 a ？这是 JS 作者在设计之初的一个很大的问题，作者将<strong>顶层对象的属性和全局变量进行了挂钩</strong>。这也是被很多人诟病的问题之一，因为当我们做一个大型项目的时候，里面有很多全局变量，如果这些全局变量都被挂载到 window 对象下面的话，那么 window 这个变量就会变得越来越大，我们也将这个称为<strong>污染全局变量</strong>。而新的声明 let 就解决了这个问题，let 不属于顶层对象 window，使用 let 声明的全局变量不会与顶层对象的属性挂钩。</p>
<h3 id="1-2-不允许重复声明"><a href="#1-2-不允许重复声明" class="headerlink" title="1.2 不允许重复声明"></a>1.2 不允许重复声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">6</span> <span class="comment">// 不会报错，后定义的会覆盖先定义的</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">6</span> <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-不存在变量提升"><a href="#1-3-不存在变量提升" class="headerlink" title="1.3 不存在变量提升"></a>1.3 不存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>以上代码不会报错，因为 var 会变量提升，相当于以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 输出 undefined</span></span><br><span class="line">a = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>但是 let 不存在变量提升：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-暂时性死区"><a href="#1-4-暂时性死区" class="headerlink" title="1.4 暂时性死区"></a>1.4 暂时性死区</h3><p>ES6 规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  a = <span class="number">6</span></span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会报错，因为花括号里形成了暂时性死区，相当于一个封闭的作用域。在这个封闭的作用域内，我们先使用 a 再用 let 定义 a 就导致了错误。有些暂时性死区是很隐蔽的，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params">a = b, b = <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo1</span>() <span class="comment">// 报错，执行 a = b 时 b 还未被定义，此时就是未定义却使用了 b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">a = <span class="number">2</span>, b = a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo2</span>() <span class="comment">// 不会报错，因为 a 在被使用前已被定义</span></span><br></pre></td></tr></table></figure>

<p>函数名后面的小括号内行成了一个暂时性死区。</p>
<p>暂时性死区的本质就是防止变量在声明之前被使用。</p>
<h3 id="1-5-块级作用域"><a href="#1-5-块级作用域" class="headerlink" title="1.5 块级作用域"></a>1.5 块级作用域</h3><p>我们都知道，在 ES5 中使用 var 定义的只有全局作用域和函数作用域，不存在块级作用域。但是在 ES6 中增加了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 输出3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 报错，i 只能在块级作用域内（此时是for循环内）使用，因此会报错并提示 i 未被定义</span></span><br></pre></td></tr></table></figure>

<p>还有一点值得注意的是，在 ES5 中，如果 if 后面只跟了一个语句，是可以省略花括号的；但是在 ES6 中，块级作用域是不可以将花括号省略掉的。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">var</span> a = <span class="number">5</span> <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> a = <span class="number">5</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>当然，我们的建议也是无论在什么时候都要把这个花括号写上。</p>
<h3 id="1-6-补充"><a href="#1-6-补充" class="headerlink" title="1.6 补充"></a>1.6 补充</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会输出三个3，因为定时器属于异步操作，要等到同步操作执行完毕且时间到达后才执行。因此当执行定时器执行时，for 循环已执行完毕，i 等于3。如何能够输出 0、1、2 呢 ，方法一就是使用我们以前学过的闭包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法就是使用 let，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也可以输出0、1、2。我们看一下以上代码被编译成 ES5 的时候是怎样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _loop = <span class="keyword">function</span> <span class="title function_">_loop</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">_loop</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是使用 let 方式，当代码被转化成 ES5 语法时，会自动形成一个闭包。</p>
<blockquote>
<p>可以进入 babel 官网，点击试一试，可以在线地将 ES6 语法转化成 ES5 语法。</p>
</blockquote>
<h2 id="二、新的声明方式：const"><a href="#二、新的声明方式：const" class="headerlink" title="二、新的声明方式：const"></a>二、新的声明方式：const</h2><ul>
<li>不属于顶层对象 window</li>
<li>不允许重复声明</li>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
</ul>
<p>const 与 let 的区别就是，let 声明的是变量，而 const 声明的是常量。</p>
<p>ES5 中定义常量的 API 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 window 对象定义名为 PI 的属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&#x27;PI&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">3.14</span> <span class="comment">// 属性值</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span> <span class="comment">// 将属性配置为不可修改，以表示常量</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 ES6 中直接使用 const 声明的就是常量，并且 const 声明的变量需要在声明的时候就被赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a</span><br><span class="line">a = <span class="number">5</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>我们知道，基本类型的值存在栈内，引用类型的值存在堆里面，栈里只存放了引用类型的引用地址。如下所示：</p>
<img src="1.jpeg"  width="80%">

<p><strong>const 定义的引用类型的引用地址不可以改变，但是引用类型的值可以改变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">24</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 输出的obj里包含age属性</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Object.freeze()</code>可以让 const 定义的对象和基本类型一样，值不能被改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj) <span class="comment">// 只有对象可以使用这个方法，数组不行</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">24</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 输出的obj里不包含age属性</span></span><br></pre></td></tr></table></figure>

<p>但是 Object.freeze() 实现的是浅层冻结，如下所示，它只能冻结 skill 属性的引用地址，但是冻结不了里面的值。如果还想冻结 skill 只能再补充 Object.freeze(obj.skill)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  <span class="attr">skill</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">    <span class="attr">year</span>: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line">obj.<span class="property">skill</span>.<span class="property">year</span> = <span class="number">11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 输出的obj的skill的year的值为11</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/15/ES001/" data-id="clur520pu0000moccaakxazgm" data-title="（一）ES6：新的声明方式 let与const" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES/" rel="tag">ES</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/02/15/ES002/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          （二）ES6：解构赋值
        
      </div>
    </a>
  
  
    <a href="/2021/02/04/HTTP005/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CORS跨域资源共享、CORS预请求</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES/" rel="tag">ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%BC%E5%90%88/" rel="tag">综合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES/" style="font-size: 20px;">ES</a> <a href="/tags/HTTP/" style="font-size: 16.67px;">HTTP</a> <a href="/tags/Vue/" style="font-size: 13.33px;">Vue</a> <a href="/tags/%E7%BB%BC%E5%90%88/" style="font-size: 10px;">综合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/18/ZH002/">浏览器中的进程</a>
          </li>
        
          <li>
            <a href="/2021/06/26/HTTP013/">HTTP缓存</a>
          </li>
        
          <li>
            <a href="/2021/05/31/HTTP012/">JSONP</a>
          </li>
        
          <li>
            <a href="/2021/05/26/HTTP011/">常见 Web 攻击总结</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Vue007/">【Vue3.x】Vue3响应式原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>